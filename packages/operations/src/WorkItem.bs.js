// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Graphql = require("graphql");
var CorePlus = require("@re-graphql-codegen/core-plus/src/CorePlus.bs.js");
var Core__List = require("@rescript/core/src/Core__List.bs.js");
var AST$Graphql = require("@re-graphql-codegen/graphql/src/AST.bs.js");
var Schema$Graphql = require("@re-graphql-codegen/graphql/src/Schema.bs.js");
var Caml_exceptions = require("rescript/lib/js/caml_exceptions.js");

var Unknown_type = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Unknown_type");

var Missing_fragment = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Missing_fragment");

var Non_input_type = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Non_input_type");

var Empty_fragment = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Empty_fragment");

var Empty_inline_fragment = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Empty_inline_fragment");

var Invalid_inline_fragment = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Invalid_inline_fragment");

var Invalid_type_condition = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Invalid_type_condition");

var Selection_on_union = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Selection_on_union");

var Empty_definition = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Empty_definition");

var Missing_base_type = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Missing_base_type");

var Unknown_field = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Unknown_field");

var Composite_type_without_fields = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Composite_type_without_fields");

var Simple_type_with_fields = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Simple_type_with_fields");

var Invalid_type_name = /* @__PURE__ */Caml_exceptions.create("WorkItem-GraphqlCodegenOperations.Invalid_type_name");

var keywords = [
  "await",
  "open",
  "true",
  "false",
  "let",
  "and",
  "rec",
  "as",
  "exception",
  "assert",
  "lazy",
  "if",
  "else",
  "for",
  "in",
  "while",
  "switch",
  "when",
  "external",
  "type",
  "private",
  "constraint",
  "mutable",
  "include",
  "module",
  "try"
];

function sanitizeFieldName(original, fields) {
  if (!keywords.includes(original)) {
    return [
            original,
            undefined
          ];
  }
  var _fieldName = original;
  while(true) {
    var fieldName = _fieldName;
    var newName = fieldName + "_";
    var match = fields[newName];
    if (match === undefined) {
      return [
              newName,
              original
            ];
    }
    _fieldName = newName;
    continue ;
  };
}

function WithGqlWrappers(Base) {
  return {};
}

var BaseInput = {};

function traverse(base, onScalar, onEnum, onObject, onListOpt, onNullOpt, onNonNullOpt) {
  var onList = onListOpt !== undefined ? onListOpt : (function (t) {
        return t;
      });
  var onNull = onNullOpt !== undefined ? onNullOpt : (function (t) {
        return t;
      });
  var onNonNull = onNonNullOpt !== undefined ? onNonNullOpt : (function (t) {
        return t;
      });
  var down = function (_t, _wrappers) {
    while(true) {
      var wrappers = _wrappers;
      var t = _t;
      switch (t.TAG) {
        case "Base" :
            var s = t._0;
            switch (s.TAG) {
              case "Scalar" :
                  return [
                          onScalar(s._0),
                          {
                            hd: onNull,
                            tl: wrappers
                          }
                        ];
              case "Enum" :
                  return [
                          onEnum(s._0),
                          {
                            hd: onNull,
                            tl: wrappers
                          }
                        ];
              case "Object" :
                  return [
                          onObject(s._0),
                          {
                            hd: onNull,
                            tl: wrappers
                          }
                        ];
              
            }
        case "List" :
            _wrappers = {
              hd: onList,
              tl: {
                hd: onNull,
                tl: wrappers
              }
            };
            _t = t._0;
            continue ;
        case "NonNull" :
            var nn = t._0;
            if (nn.TAG === "Base_nn") {
              var s$1 = nn._0;
              switch (s$1.TAG) {
                case "Scalar" :
                    return [
                            onScalar(s$1._0),
                            {
                              hd: onNonNull,
                              tl: wrappers
                            }
                          ];
                case "Enum" :
                    return [
                            onEnum(s$1._0),
                            {
                              hd: onNonNull,
                              tl: wrappers
                            }
                          ];
                case "Object" :
                    return [
                            onObject(s$1._0),
                            {
                              hd: onNonNull,
                              tl: wrappers
                            }
                          ];
                
              }
            } else {
              _wrappers = {
                hd: onList,
                tl: {
                  hd: onNonNull,
                  tl: wrappers
                }
              };
              _t = nn._0;
              continue ;
            }
        
      }
    };
  };
  var _param = down(base, /* [] */0);
  while(true) {
    var param = _param;
    var wrappers = param[1];
    var v = param[0];
    if (!wrappers) {
      return v;
    }
    _param = [
      wrappers.hd(v),
      wrappers.tl
    ];
    continue ;
  };
}

var InputType = {
  traverse: traverse
};

var BaseUnresolvedOutput = {};

function combineSelectionSets(param, param$1) {
  return {
          type_: param.type_,
          fields: CorePlus.Dict.mergeWith(param.fields, param$1.fields, (function (prim0, prim1) {
                  return prim0.concat(prim1);
                }))
        };
}

function mergeSelectionSets(param) {
  return CorePlus.$$Array.reduce(param[1], param[0], (function (param, param$1) {
                return {
                        type_: param.type_,
                        fields: CorePlus.Dict.mergeWith(param.fields, param$1.fields, (function (prim0, prim1) {
                                return prim0.concat(prim1);
                              }))
                      };
              }));
}

function combineUnions(u1, u2) {
  return {
          type_: u1.type_,
          base: CorePlus.$$Option.liftConcat(combineSelectionSets, u1.base, u2.base),
          members: CorePlus.Dict.mergeWith(u1.members, u2.members, combineSelectionSets)
        };
}

function mergeUnions(param) {
  return CorePlus.$$Array.reduce(param[1], param[0], combineUnions);
}

function mergeLike(t1, t2) {
  var ss;
  var type_;
  var base;
  var members;
  if (t1.TAG === "SelectionSet") {
    var ss1 = t1._0;
    if (t2.TAG === "SelectionSet") {
      return {
              TAG: "SelectionSet",
              _0: combineSelectionSets(ss1, t2._0)
            };
    }
    var match = t2._0;
    ss = ss1;
    type_ = match.type_;
    base = match.base;
    members = match.members;
  } else {
    var u1 = t1._0;
    if (t2.TAG !== "SelectionSet") {
      return {
              TAG: "Union",
              _0: combineUnions(u1, t2._0)
            };
    }
    ss = t2._0;
    type_ = u1.type_;
    base = u1.base;
    members = u1.members;
  }
  return {
          TAG: "Union",
          _0: {
            type_: type_,
            base: CorePlus.$$Option.liftConcat(combineSelectionSets, base, ss),
            members: members
          }
        };
}

function combineLike(param) {
  return CorePlus.$$Array.reduce(param[1], param[0], mergeLike);
}

var UnresolvedOutputType = {
  combineSelectionSets: combineSelectionSets,
  mergeSelectionSets: mergeSelectionSets,
  combineUnions: combineUnions,
  mergeUnions: mergeUnions,
  mergeLike: mergeLike,
  combineLike: combineLike
};

function fromDefinitions(definitions) {
  return Core__List.fromArray(definitions.toReversed().map(function (d) {
                  return {
                          TAG: "PrintDefinition",
                          _0: d
                        };
                }));
}

function joinPath(path) {
  return path.join("_");
}

function nonTypenameSelections(selections) {
  return AST$Graphql.SelectionSetNode.selections(selections).filter(function (s) {
              switch (s.kind) {
                case "Field" :
                    return AST$Graphql.NameNode.value(s.name) !== "__typename";
                case "FragmentSpread" :
                case "InlineFragment" :
                    return true;
                
              }
            });
}

function $$process(steps, fragments, schema, baseTypesModule, scalarModule, nullType, listType) {
  var formatModuleName = function (path) {
    var match = path.slice(0, 2);
    var len = match.length;
    if (len >= 3) {
      throw {
            RE_EXN_ID: Invalid_type_name,
            _1: path,
            Error: new Error()
          };
    }
    var ls;
    switch (len) {
      case 0 :
          throw {
                RE_EXN_ID: Invalid_type_name,
                _1: path,
                Error: new Error()
              };
      case 1 :
          var match$1 = match[0];
          if (match$1 === "t") {
            ls = ["t"];
          } else {
            throw {
                  RE_EXN_ID: Invalid_type_name,
                  _1: path,
                  Error: new Error()
                };
          }
          break;
      case 2 :
          var match$2 = match[0];
          switch (match$2) {
            case "inner" :
                var match$3 = match[1];
                if (match$3 === "t") {
                  ls = ["inner"].concat(path.slice(2));
                } else {
                  throw {
                        RE_EXN_ID: Invalid_type_name,
                        _1: path,
                        Error: new Error()
                      };
                }
                break;
            case "t" :
                ls = path.slice(1);
                break;
            default:
              throw {
                    RE_EXN_ID: Invalid_type_name,
                    _1: path,
                    Error: new Error()
                  };
          }
          break;
      
    }
    return ls.map(CorePlus.$$String.capitalize).join("");
  };
  var extractInputType = function (typeNode) {
    var named = function (nameNode) {
      var name = AST$Graphql.NameNode.value(nameNode);
      var s = CorePlus.$$Option.getOrExn(CorePlus.$$Option.map(Schema$Graphql.getType(schema, name), Schema$Graphql.Named.parse), {
            RE_EXN_ID: Unknown_type,
            _1: name
          });
      switch (s.TAG) {
        case "Scalar" :
            return {
                    TAG: "Scalar",
                    _0: Schema$Graphql.Scalar.name(s._0)
                  };
        case "Enum" :
            return {
                    TAG: "Enum",
                    _0: Schema$Graphql.Enum.name(s._0)
                  };
        case "InputObject" :
            return {
                    TAG: "Object",
                    _0: Schema$Graphql.InputObject.name(s._0)
                  };
        default:
          throw {
                RE_EXN_ID: Non_input_type,
                _1: name,
                Error: new Error()
              };
      }
    };
    var base = function (typeNode) {
      switch (typeNode.kind) {
        case "NamedType" :
            return {
                    TAG: "Base",
                    _0: named(typeNode.name)
                  };
        case "ListType" :
            return {
                    TAG: "List",
                    _0: base(typeNode.type)
                  };
        case "NonNullType" :
            var type_ = typeNode.type;
            var tmp;
            tmp = type_.kind === "NamedType" ? ({
                  TAG: "Base_nn",
                  _0: named(type_.name)
                }) : ({
                  TAG: "List_nn",
                  _0: base(type_.type)
                });
            return {
                    TAG: "NonNull",
                    _0: tmp
                  };
        
      }
    };
    return base(typeNode);
  };
  var extractSelectionType = function (baseType, param) {
    var extractFields = function (node, type_) {
      switch (node.kind) {
        case "Field" :
            return {
                    TAG: "SelectionSet",
                    _0: {
                      type_: CorePlus.$$Option.getOrExn(Schema$Graphql.ValidForField.fromValidForTypeCondition(type_), {
                            RE_EXN_ID: Selection_on_union,
                            _1: Schema$Graphql.ValidForTypeCondition.name(type_)
                          }),
                      fields: Object.fromEntries([[
                              AST$Graphql.NameNode.value(node.name),
                              CorePlus.$$Option.toArray(node.selectionSet)
                            ]])
                    }
                  };
        case "FragmentSpread" :
            var fragmentName = AST$Graphql.NameNode.value(node.name);
            var match = CorePlus.$$Option.getOrExn(CorePlus.$$Array.headTail(nonTypenameSelections(AST$Graphql.FragmentDefinitionNode.selectionSet(CorePlus.$$Option.getOrExn(fragments[fragmentName], {
                                  RE_EXN_ID: Missing_fragment,
                                  _1: fragmentName
                                })))), {
                  RE_EXN_ID: Empty_fragment,
                  _1: fragmentName
                });
            return combineLike([
                        extractFields(match[0], type_),
                        match[1].map(function (__x) {
                              return extractFields(__x, type_);
                            })
                      ]);
        case "InlineFragment" :
            var typeCondition = node.typeCondition;
            if (typeCondition !== undefined) {
              var validatedBase;
              switch (baseType.TAG) {
                case "Object" :
                    throw {
                          RE_EXN_ID: Invalid_inline_fragment,
                          _1: Schema$Graphql.$$Object.name(baseType._0),
                          Error: new Error()
                        };
                case "Interface" :
                    validatedBase = Schema$Graphql.Interface.toAbstract(baseType._0);
                    break;
                case "Union" :
                    validatedBase = Schema$Graphql.Union.toAbstract(baseType._0);
                    break;
                
              }
              var typeName = AST$Graphql.NameNode.value(AST$Graphql.NamedTypeNode.name(typeCondition));
              var selectionType = CorePlus.$$Option.getOrExn(Schema$Graphql.ValidForTypeCondition.fromNamed(Schema$Graphql.Named.parse(CorePlus.$$Option.getOrExn(Schema$Graphql.getType(schema, typeName), {
                                RE_EXN_ID: Unknown_type,
                                _1: typeName
                              }))), {
                    RE_EXN_ID: Invalid_type_condition,
                    _1: typeName
                  });
              var merged = combineLike(CorePlus.$$Option.getOrExn(CorePlus.$$Array.headTail(nonTypenameSelections(node.selectionSet).map(function (__x) {
                                return extractFields(__x, selectionType);
                              })), {
                        RE_EXN_ID: Empty_inline_fragment
                      }));
              if (merged.TAG === "SelectionSet") {
                return {
                        TAG: "Union",
                        _0: {
                          type_: validatedBase,
                          members: Object.fromEntries([[
                                  typeName,
                                  merged._0
                                ]])
                        }
                      };
              }
              var u = merged._0;
              var base = u.base;
              if (base === undefined) {
                return {
                        TAG: "Union",
                        _0: u
                      };
              }
              var basePair = [
                typeName,
                base
              ];
              var memberPairs = Object.entries(u.members).map(function (param) {
                    return [
                            param[0],
                            combineSelectionSets(base, param[1])
                          ];
                  });
              return {
                      TAG: "Union",
                      _0: {
                        type_: validatedBase,
                        members: Object.fromEntries([basePair].concat(memberPairs))
                      }
                    };
            }
            var match$1 = CorePlus.$$Option.getOrExn(CorePlus.$$Array.headTail(nonTypenameSelections(node.selectionSet)), {
                  RE_EXN_ID: Empty_inline_fragment
                });
            return combineLike([
                        extractFields(match$1[0], type_),
                        match$1[1].map(function (__x) {
                              return extractFields(__x, type_);
                            })
                      ]);
        
      }
    };
    return combineLike([
                extractFields(param[0], baseType),
                param[1].map(function (__x) {
                      return extractFields(__x, baseType);
                    })
              ]);
  };
  var processStep = function (t) {
    switch (t.TAG) {
      case "PrintString" :
          return [
                  /* [] */0,
                  [t._0]
                ];
      case "PrintType" :
          var type_ = t.type_;
          var namePath = t.namePath;
          var extractNamed = function (type_) {
            return Schema$Graphql.Output.traverse(type_, (function (s) {
                          return {
                                  TAG: "Left",
                                  _0: [
                                    Schema$Graphql.Scalar.name(s),
                                    Schema$Graphql.Scalar.print(s, scalarModule)
                                  ]
                                };
                        }), (function (o) {
                          return {
                                  TAG: "Right",
                                  _0: [
                                    Schema$Graphql.$$Object.name(o),
                                    {
                                      TAG: "Object",
                                      _0: o
                                    },
                                    (function (i) {
                                        return i;
                                      })
                                  ]
                                };
                        }), (function (i) {
                          return {
                                  TAG: "Right",
                                  _0: [
                                    Schema$Graphql.Interface.name(i),
                                    {
                                      TAG: "Interface",
                                      _0: i
                                    },
                                    (function (i) {
                                        return i;
                                      })
                                  ]
                                };
                        }), (function (u) {
                          return {
                                  TAG: "Right",
                                  _0: [
                                    Schema$Graphql.Union.name(u),
                                    {
                                      TAG: "Union",
                                      _0: u
                                    },
                                    (function (i) {
                                        return i;
                                      })
                                  ]
                                };
                        }), (function (e) {
                          return {
                                  TAG: "Left",
                                  _0: [
                                    Schema$Graphql.Enum.name(e),
                                    Schema$Graphql.Enum.print(e, baseTypesModule)
                                  ]
                                };
                        }), (function (e) {
                          if (e.TAG === "Left") {
                            var match = e._0;
                            return {
                                    TAG: "Left",
                                    _0: [
                                      match[0],
                                      listType + "<" + match[1] + ">"
                                    ]
                                  };
                          }
                          var match$1 = e._0;
                          var w = match$1[2];
                          return {
                                  TAG: "Right",
                                  _0: [
                                    match$1[0],
                                    match$1[1],
                                    (function (s) {
                                        return listType + "<" + w(s) + ">";
                                      })
                                  ]
                                };
                        }), (function (e) {
                          if (e.TAG === "Left") {
                            var match = e._0;
                            return {
                                    TAG: "Left",
                                    _0: [
                                      match[0],
                                      nullType + "<" + match[1] + ">"
                                    ]
                                  };
                          }
                          var match$1 = e._0;
                          var w = match$1[2];
                          return {
                                  TAG: "Right",
                                  _0: [
                                    match$1[0],
                                    match$1[1],
                                    (function (s) {
                                        return nullType + "<" + w(s) + ">";
                                      })
                                  ]
                                };
                        }), undefined);
          };
          var parseSelectionSet = function (param, midfix) {
            var fields = param.fields;
            var type_ = param.type_;
            var lookup;
            lookup = type_.TAG === "Object" ? Schema$Graphql.$$Object.getFields(type_._0) : Schema$Graphql.Interface.getFields(type_._0);
            return Object.entries(fields).map(function (param) {
                        var rawKey = param[0];
                        var match = sanitizeFieldName(rawKey, fields);
                        var alias = match[1];
                        var fieldType = Schema$Graphql.Field.type_(CorePlus.$$Option.getOrExn(lookup[rawKey], {
                                  RE_EXN_ID: Unknown_field,
                                  _1: rawKey
                                }));
                        var selections = param[1].flatMap(nonTypenameSelections);
                        var match$1 = CorePlus.$$Array.headTail(selections);
                        var match$2 = extractNamed(fieldType);
                        var match$3;
                        if (match$1 !== undefined) {
                          if (match$2.TAG === "Left") {
                            throw {
                                  RE_EXN_ID: Composite_type_without_fields,
                                  _1: match$2._0[0],
                                  Error: new Error()
                                };
                          }
                          var match$4 = match$2._0;
                          var res = extractSelectionType(match$4[1], [
                                match$1[0],
                                match$1[1]
                              ]);
                          var fieldPath = CorePlus.$$Option.mapOr(midfix, namePath.concat([rawKey]), (function (m) {
                                  return namePath.concat([
                                              m,
                                              rawKey
                                            ]);
                                }));
                          match$3 = [
                            match$4[2](joinPath(fieldPath)),
                            {
                              TAG: "PrintType",
                              namePath: fieldPath,
                              type_: res
                            }
                          ];
                        } else if (match$2.TAG === "Left") {
                          match$3 = [
                            match$2._0[1],
                            undefined
                          ];
                        } else {
                          throw {
                                RE_EXN_ID: Simple_type_with_fields,
                                _1: match$2._0[0],
                                Error: new Error()
                              };
                        }
                        var mainLine = "    " + match[0] + ": " + match$3[0] + ",";
                        return [
                                alias !== undefined ? [
                                      "    @as(\"" + alias + "\")",
                                      mainLine
                                    ].join("\n") : mainLine,
                                match$3[1]
                              ];
                      });
          };
          var match;
          if (type_.TAG === "SelectionSet") {
            var results = parseSelectionSet(type_._0, undefined);
            var lines = results.map(function (param) {
                  return param[0];
                });
            var bases = CorePlus.$$Array.filterMap(results, (function (param) {
                    return param[1];
                  }));
            var name = joinPath(namePath);
            match = [
              [].concat(["  type " + name + " = {"], lines, ["  }"]),
              bases
            ];
          } else {
            var match$1 = type_._0;
            var members = match$1.members;
            var base = match$1.base;
            var possibleTypes = Schema$Graphql.getPossibleTypes(schema, match$1.type_);
            var results$1 = possibleTypes.map(function (objectType) {
                  var typeConditionName = Schema$Graphql.$$Object.name(objectType);
                  var match = members[typeConditionName];
                  var selectionSet = base !== undefined ? (
                      match !== undefined ? combineSelectionSets(base, match) : (
                          match !== undefined ? match : base
                        )
                    ) : (
                      match !== undefined ? match : base
                    );
                  return CorePlus.$$Option.mapOr(selectionSet, [
                              ["      | " + CorePlus.$$String.capitalize(typeConditionName)],
                              []
                            ], (function (ss) {
                                var fields = parseSelectionSet(ss, typeConditionName);
                                var lines = fields.map(function (param) {
                                      return param[0];
                                    });
                                var bases = CorePlus.$$Array.filterMap(fields, (function (param) {
                                        return param[1];
                                      }));
                                return [
                                        [].concat(["      | " + CorePlus.$$String.capitalize(typeConditionName) + "({"], lines.map(function (l) {
                                                  return "    " + l;
                                                }), ["      })"]),
                                        bases
                                      ];
                              }));
                });
            var moduleName = formatModuleName(namePath);
            match = [
              [].concat(["  module " + moduleName + " = {"], ["    @tag(\"__typename\")"], ["    type t ="], results$1.flatMap(function (param) {
                        return param[0];
                      }), ["  }"], ["  type " + joinPath(namePath) + " = " + moduleName + ".t"]),
              results$1.flatMap(function (param) {
                    return param[1];
                  })
            ];
          }
          return [
                  Core__List.fromArray(match[1]),
                  match[0]
                ];
      case "PrintVariables" :
          var fields = t.fields;
          return [
                  /* [] */0,
                  [].concat(["  let variables = {"], Object.entries(fields).map(function (param) {
                            var match = sanitizeFieldName(param[0], fields);
                            var alias = match[1];
                            var value = traverse(param[1], (function (s) {
                                    return scalarModule + "." + s + ".t";
                                  }), (function (s) {
                                    return baseTypesModule + "." + s + ".t";
                                  }), (function (s) {
                                    return baseTypesModule + "." + s + ".t";
                                  }), (function (s) {
                                    return listType + "<" + s + ">";
                                  }), (function (s) {
                                    return nullType + "<" + s + ">";
                                  }), undefined);
                            var mainLine = "    " + match[0] + ": " + value;
                            if (alias !== undefined) {
                              return [
                                        "    @as(\"" + alias + "\")",
                                        mainLine
                                      ].join("\n");
                            } else {
                              return mainLine;
                            }
                          }), ["  }"])
                ];
      case "PrintDocument" :
          return [
                  /* [] */0,
                  [].concat(["  let document = `"], Graphql.print(t._0).split("\n").map(function (l) {
                            return "    " + l;
                          }), ["  `"])
                ];
      case "PrintDefinition" :
          var definition = t._0;
          var definitionName;
          definitionName = definition.kind === "OperationDefinition" ? CorePlus.$$Option.map(definition.name, AST$Graphql.NameNode.value) : AST$Graphql.NameNode.value(definition.name);
          var baseType;
          if (definition.kind === "OperationDefinition") {
            var operation = definition.operation;
            var tmp;
            switch (operation) {
              case "query" :
                  tmp = Schema$Graphql.getQueryType(schema);
                  break;
              case "mutation" :
                  tmp = Schema$Graphql.getMutationType(schema);
                  break;
              case "subscription" :
                  tmp = Schema$Graphql.getSubscriptionType(schema);
                  break;
              
            }
            baseType = {
              TAG: "Object",
              _0: CorePlus.$$Option.getOrExn(tmp, {
                    RE_EXN_ID: Missing_base_type,
                    _1: operation
                  })
            };
          } else {
            var conditionName = AST$Graphql.NameNode.value(AST$Graphql.NamedTypeNode.name(definition.typeCondition));
            baseType = CorePlus.$$Option.getOrExn(Schema$Graphql.ValidForTypeCondition.fromNamed(Schema$Graphql.Named.parse(CorePlus.$$Option.getOrExn(Schema$Graphql.getType(schema, conditionName), {
                              RE_EXN_ID: Unknown_type,
                              _1: AST$Graphql.NameNode.value(definition.name)
                            }))), {
                  RE_EXN_ID: Invalid_type_condition,
                  _1: conditionName
                });
          }
          var match$2;
          match$2 = definition.kind === "OperationDefinition" ? [
              definition.variableDefinitions,
              definition.selectionSet
            ] : [
              definition.variableDefinitions,
              definition.selectionSet
            ];
          var variables = Object.fromEntries(CorePlus.$$Option.getOr(match$2[0], []).map(function (a) {
                    return [
                            AST$Graphql.NameNode.value(AST$Graphql.VariableNode.name(AST$Graphql.VariableDefinitionNode.variable(a))),
                            extractInputType(AST$Graphql.VariableDefinitionNode.type_(a))
                          ];
                  }));
          var selectionSteps = (function (__x) {
                return extractSelectionType(baseType, __x);
              })(CorePlus.$$Option.getOrExn(CorePlus.$$Array.headTail(nonTypenameSelections(match$2[1])), {
                    RE_EXN_ID: Empty_definition,
                    _1: CorePlus.$$Option.getOr(definitionName, "<unnamed operation>")
                  }));
          return [
                  {
                    hd: {
                      TAG: "PrintType",
                      namePath: ["t"],
                      type_: selectionSteps
                    },
                    tl: {
                      hd: {
                        TAG: "PrintVariables",
                        fields: variables
                      },
                      tl: {
                        hd: {
                          TAG: "PrintDocument",
                          _0: definition
                        },
                        tl: {
                          hd: {
                            TAG: "PrintString",
                            _0: "module " + CorePlus.$$Option.getOr(definitionName, "Operation") + " = {"
                          },
                          tl: /* [] */0
                        }
                      }
                    }
                  },
                  ["}"]
                ];
      
    }
  };
  var _remaining = steps;
  var _output = "";
  while(true) {
    var output = _output;
    var remaining = _remaining;
    if (!remaining) {
      return output;
    }
    var match = processStep(remaining.hd);
    _output = match[1].concat([output]).join("\n");
    _remaining = Core__List.concat(match[0], remaining.tl);
    continue ;
  };
}

exports.Unknown_type = Unknown_type;
exports.Missing_fragment = Missing_fragment;
exports.Non_input_type = Non_input_type;
exports.Empty_fragment = Empty_fragment;
exports.Empty_inline_fragment = Empty_inline_fragment;
exports.Invalid_inline_fragment = Invalid_inline_fragment;
exports.Invalid_type_condition = Invalid_type_condition;
exports.Selection_on_union = Selection_on_union;
exports.Empty_definition = Empty_definition;
exports.Missing_base_type = Missing_base_type;
exports.Unknown_field = Unknown_field;
exports.Composite_type_without_fields = Composite_type_without_fields;
exports.Simple_type_with_fields = Simple_type_with_fields;
exports.Invalid_type_name = Invalid_type_name;
exports.keywords = keywords;
exports.sanitizeFieldName = sanitizeFieldName;
exports.WithGqlWrappers = WithGqlWrappers;
exports.BaseInput = BaseInput;
exports.InputType = InputType;
exports.BaseUnresolvedOutput = BaseUnresolvedOutput;
exports.UnresolvedOutputType = UnresolvedOutputType;
exports.fromDefinitions = fromDefinitions;
exports.joinPath = joinPath;
exports.nonTypenameSelections = nonTypenameSelections;
exports.$$process = $$process;
/* graphql Not a pure module */
